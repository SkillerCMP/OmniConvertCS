
using System;
using System.Numerics;

namespace OmniconvertCS
{
    /// <summary>
    /// CodeBreaker v1/v7 RSA helper.
    /// This replaces the original libbig_int-based RSACrypt() in cb2_crypto.c
    /// while keeping the same modulus and exponents.
    /// </summary>
    public static class Cb2Crypto
    {
        // These values come directly from cb2_crypto.c:
        //   static const u64 rsa_modulus = 18446744073709551605ULL; // = 0xFFFFFFFFFFFFFFF5
        //   static const u64 rsa_dec_key = 11;
        //   static const u64 rsa_enc_key = 2682110966135737091ULL;
        //
        // In the original C implementation, RSACrypt() treated the 64‑bit
        // value (addr:val) as a big_int and applied modular exponentiation
        // with these parameters.
        private const ulong RsaModulusValue = 0xFFFFFFFFFFFFFFF5UL;
        private const ulong RsaDecKeyValue  = 11UL;
        private const ulong RsaEncKeyValue  = 2682110966135737091UL;

        private static readonly BigInteger RsaModulus = new BigInteger(RsaModulusValue);
        private static readonly BigInteger RsaDecKey  = new BigInteger(RsaDecKeyValue);
        private static readonly BigInteger RsaEncKey  = new BigInteger(RsaEncKeyValue);

        /// <summary>
        /// Core RSA transform used by CodeBreaker v7.
        /// 
        /// The original signature was:
        ///   void RSACrypt(u32 *addr, u32 *val, u64 rsakey)
        /// where (*addr,*val) together form a 64‑bit integer:
        ///   code = ((u64)*addr << 32) | *val;
        ///
        /// This method keeps the same layout and math, but uses
        /// System.Numerics.BigInteger instead of libbig_int.
        /// </summary>
        /// <param name="addr">High 32 bits (in/out).</param>
        /// <param name="val">Low 32 bits (in/out).</param>
        /// <param name="encrypt">If true, use the public key; otherwise decrypt with the private key.</param>
        public static void RSACrypt(ref uint addr, ref uint val, bool encrypt)
        {
            // Compose 64‑bit value from the two 32‑bit words.
            ulong code64 = ((ulong)addr << 32) | (ulong)val;

            // The original code only ran the exponentiation when the value
            // was strictly less than the modulus.
            if (code64 >= RsaModulusValue)
            {
                return;
            }

            BigInteger code = new BigInteger(code64);
            BigInteger exp  = encrypt ? RsaEncKey : RsaDecKey;

            BigInteger result = BigInteger.ModPow(code, exp, RsaModulus);
            ulong r = (ulong)result; // The result is guaranteed to fit in 64 bits.

            addr = (uint)(r >> 32);
            val  = (uint)(r & 0xFFFFFFFFu);
        }

        /// <summary>
        /// Convenience wrapper that matches the original decrypt usage:
        /// RSACrypt(&addr, &val, rsa_dec_key);
        /// </summary>
        public static void RSADecode(ref uint addr, ref uint val)
        {
            RSACrypt(ref addr, ref val, encrypt: false);
        }

        /// <summary>
        /// Convenience wrapper that matches the original encrypt usage:
        /// RSACrypt(&addr, &val, rsa_enc_key);
        /// </summary>
        public static void RSAEncode(ref uint addr, ref uint val)
        {
            RSACrypt(ref addr, ref val, encrypt: true);
        }
        // V1 seed table (direct port of cb2_crypto.c)
        private static readonly uint[,] SeedTable = new uint[3, 16]
        {
            { 0x0A0B8D9B, 0x0A0133F8, 0x0AF733EC, 0x0A15C574, 0x0A50AC20, 0x0A920FB9, 0x0A599F0B, 0x0A4AA0E3, 0x0A21C012, 0x0A906254, 0x0A31FD54, 0x0A091C0E, 0x0A372B38, 0x0A6F266C, 0x0A61DD4A, 0x0A0DBF92 },
            { 0x00288596, 0x0037DD28, 0x003BEEF1, 0x000BC822, 0x00BC935D, 0x00A139F2, 0x00E9BBF8, 0x00F57F7B, 0x0090D704, 0x001814D4, 0x00C5848E, 0x005B83E7, 0x00108CF7, 0x0046CE5A, 0x003A5BF4, 0x006FAFFC },
            { 0x1DD9A10A, 0xB95AB9B0, 0x5CF5D328, 0x95FE7F10, 0x8E2D6303, 0x16BB6286, 0xE389324C, 0x07AC6EA8, 0xAA4811D8, 0x76CE4E18, 0xFE447516, 0xF9CD94D0, 0x4C24DEDB, 0x68275C4E, 0x72494382, 0xC8AA88E8 }
        };


/// <summary>
/// Compute multiplicative inverse of <paramref name="word"/> modulo 2^32.
/// Direct port of MulInverse() from cb2_crypto.c.
/// </summary>
private static uint MulInverse(uint word)
{
    unchecked
    {
        // Original MIPS R5900 coding converted to C# (uint arithmetic wraps modulo 2^32).
        uint a0, a1, a2, a3;
        uint v0, v1;
        uint t1;

        if (word == 1U)
            return 1U;

        a2 = (0U - word) % word;
        if (a2 == 0U)
            return 1U;

        t1 = 1U;
        a3 = word;
        a0 = 0U - (0xFFFFFFFFU / word);

        do
        {
            v0 = a3 / a2;
            v1 = a3 % a2;
            a1 = a2;
            a3 = a1;
            a1 = a0;
            a2 = v1;
            v0 = v0 * a1;
            a0 = t1 - v0;
            t1 = a1;
        } while (a2 != 0U);

        return t1;
    }
}

/// <summary>
/// Multiply modulo 2^32 with (b | 1). Direct port of MulEncrypt().
/// </summary>
private static uint MulEncrypt(uint a, uint b)
{
    unchecked
    {
        return a * (b | 1U);
    }
}

/// <summary>
/// Multiply modulo 2^32 by the multiplicative inverse of (b | 1). Direct port of MulDecrypt().
/// </summary>
private static uint MulDecrypt(uint a, uint b)
{
    unchecked
    {
        return a * MulInverse(b | 1U);
    }
}

/// <summary>
/// Reset CB2 V7 state flags. Direct port of CBReset() semantics.
/// (V7 seed/key handling is not yet implemented, but this keeps the state model consistent.)
/// </summary>
public static void CBReset()
{
    v7enc = false;
    v7init = false;
    beefcodf = 0;
}

// Flags used by the original V7 implementation.
// Full V7 (CB7EncryptCode/CB7DecryptCode/CB7Beefcode) will be ported in a later step.
private static bool v7enc;
private static bool v7init;
private static int beefcodf;

        // V7 seeds, keys, and file key (direct ports of defseeds/defkey/filekey from cb2_crypto.c)
        private static readonly byte[][] DefSeeds = new byte[][]
        {
            new byte[] { 0x84, 0x01, 0x21, 0xA4, 0xFA, 0x4D, 0x50, 0x8D, 0x75, 0x33, 0xC5, 0xF7, 0x4A, 0x6D, 0x7C, 0xA6,
                0x1C, 0xF8, 0x40, 0x18, 0xA1, 0xB3, 0xA2, 0xF9, 0x6A, 0x19, 0x63, 0x66, 0x29, 0xAE, 0x10, 0x75,
                0x84, 0x7D, 0xEC, 0x6A, 0xF9, 0x2D, 0x8E, 0x33, 0x44, 0x5C, 0x33, 0x6D, 0x78, 0x3E, 0x1B, 0x6C,
                0x02, 0xE0, 0x7D, 0x77, 0x1D, 0xB1, 0x61, 0x2A, 0xCD, 0xC1, 0x38, 0x53, 0x1F, 0xA1, 0x6E, 0x3D,
                0x03, 0x0D, 0x05, 0xDC, 0x50, 0x19, 0x85, 0x89, 0x9B, 0xF1, 0x8A, 0xC2, 0xD1, 0x5C, 0x22, 0xC4,
                0x11, 0x29, 0xF6, 0x13, 0xEC, 0x06, 0xE4, 0xBD, 0x08, 0x9E, 0xB7, 0x8D, 0x72, 0x92, 0x10, 0x3C,
                0x41, 0x4E, 0x81, 0x55, 0x08, 0x9C, 0xA3, 0xBC, 0xA1, 0x79, 0xB0, 0x7A, 0x94, 0x3A, 0x39, 0x95,
                0x7A, 0xC6, 0x96, 0x21, 0xB0, 0x07, 0x17, 0x5E, 0x53, 0x54, 0x08, 0xCF, 0x85, 0x6C, 0x4B, 0xBE,
                0x30, 0x82, 0xDD, 0x1D, 0x3A, 0x24, 0x3C, 0xB2, 0x67, 0x0C, 0x36, 0x03, 0x51, 0x60, 0x3F, 0x67,
                0xF1, 0xB2, 0x77, 0xDC, 0x12, 0x9D, 0x7B, 0xCE, 0x65, 0xF8, 0x75, 0xEA, 0x23, 0x63, 0x99, 0x54,
                0x37, 0xC0, 0x3C, 0x42, 0x77, 0x12, 0xB7, 0xCA, 0x54, 0xF1, 0x26, 0x1D, 0x1E, 0xD1, 0xAB, 0x2C,
                0xAF, 0xB6, 0x91, 0x2E, 0xBD, 0x84, 0x0B, 0xF2, 0x1A, 0x1E, 0x26, 0x1E, 0x00, 0x12, 0xB7, 0x77,
                0xD6, 0x61, 0x1C, 0xCE, 0xA9, 0x10, 0x19, 0xAA, 0x88, 0xE6, 0x35, 0x29, 0x32, 0x5F, 0x57, 0xA7,
                0x94, 0x93, 0xA1, 0x2B, 0xEB, 0x9B, 0x17, 0x2A, 0xAA, 0x60, 0xD5, 0x19, 0xB2, 0x4E, 0x5A, 0xE2,
                0xC9, 0x4A, 0x00, 0x68, 0x6E, 0x59, 0x36, 0xA6, 0xA0, 0xF9, 0x19, 0xA2, 0xC7, 0xC9, 0xD4, 0x29,
                0x5C, 0x99, 0x3C, 0x5C, 0xE2, 0xCB, 0x94, 0x40, 0x8B, 0xF4, 0x3B, 0xD2, 0x38, 0x7D, 0xBF, 0xD0 },
            new byte[] { 0xCC, 0x6D, 0x5D, 0x0B, 0x70, 0x25, 0x5D, 0x68, 0xFE, 0xBE, 0x6C, 0x3F, 0xA4, 0xD9, 0x95, 0x5F,
                0x30, 0xAE, 0x34, 0x39, 0x00, 0x89, 0xDC, 0x5A, 0xC8, 0x82, 0x24, 0x3A, 0xFC, 0xDA, 0x3C, 0x1F,
                0x73, 0x3F, 0x63, 0xAA, 0x53, 0xBD, 0x4E, 0xB5, 0x33, 0x48, 0x59, 0xC1, 0xB7, 0xE0, 0x0C, 0x99,
                0xEC, 0x3B, 0x32, 0x26, 0xB3, 0xB1, 0xE2, 0x8E, 0x54, 0x41, 0x55, 0xDB, 0x1D, 0x90, 0x0B, 0x48,
                0xF3, 0x3F, 0xCA, 0x1F, 0x19, 0xEB, 0x7F, 0x56, 0x52, 0xD7, 0x20, 0x67, 0x59, 0x4F, 0x4E, 0xDC,
                0xBB, 0x6A, 0x8E, 0x45, 0x88, 0x0B, 0x93, 0xAC, 0xCD, 0x0E, 0x29, 0x18, 0x7A, 0x16, 0x8D, 0x8D,
                0xC2, 0x88, 0x6A, 0x9D, 0x39, 0xF4, 0x93, 0x14, 0xCD, 0xE0, 0x6B, 0xC7, 0x28, 0x21, 0x5C, 0x97,
                0x70, 0x7C, 0xAB, 0x53, 0x46, 0x33, 0x03, 0x18, 0xDF, 0x91, 0xFE, 0x06, 0xC0, 0xFF, 0xA2, 0x58,
                0xF3, 0xB0, 0x6B, 0x9B, 0x71, 0x91, 0x23, 0xDA, 0x92, 0x67, 0x14, 0x34, 0x9F, 0xA5, 0xAF, 0x65,
                0x62, 0xE8, 0x7F, 0x79, 0x35, 0x32, 0x29, 0x3E, 0x4F, 0xDC, 0xC7, 0x8E, 0xF1, 0x21, 0x9D, 0x3B,
                0x61, 0xFC, 0x0B, 0x02, 0xEC, 0xE4, 0xA7, 0xEA, 0x77, 0xE7, 0x21, 0x63, 0x97, 0x7F, 0x23, 0x8A,
                0x8B, 0xBE, 0x4E, 0x90, 0xC0, 0x89, 0x04, 0x44, 0x90, 0x57, 0x41, 0xB5, 0x74, 0xAD, 0xB1, 0xE9,
                0xF3, 0x91, 0xC7, 0x27, 0x3E, 0x00, 0x81, 0x99, 0xEE, 0x38, 0xF5, 0x32, 0x4F, 0x27, 0x4F, 0x64,
                0x39, 0x3D, 0xD3, 0x0B, 0x99, 0xD5, 0x99, 0xD6, 0x10, 0x4B, 0x43, 0x17, 0x38, 0x34, 0x54, 0x63,
                0x19, 0x36, 0xBD, 0x15, 0xB1, 0x06, 0x1E, 0xDE, 0x1B, 0xAF, 0xEB, 0xFA, 0x56, 0xB8, 0x8D, 0x9D,
                0x14, 0x1A, 0xA6, 0x49, 0x56, 0x19, 0xCA, 0xC1, 0x40, 0x6D, 0x71, 0xDE, 0x68, 0xC1, 0xC3, 0x4A },
            new byte[] { 0x69, 0x31, 0x5C, 0xAB, 0x7F, 0x5B, 0xE9, 0x81, 0x32, 0x58, 0x32, 0x0A, 0x97, 0xF3, 0xC7, 0xCF,
                0xBB, 0x1D, 0xCF, 0x0E, 0x83, 0x35, 0x4C, 0x58, 0xCE, 0xF7, 0x8A, 0xE4, 0xB0, 0xE4, 0x83, 0x48,
                0x81, 0x77, 0x7C, 0x3F, 0xBC, 0x27, 0x3A, 0x1B, 0xA4, 0xE9, 0x06, 0xA4, 0x15, 0xAB, 0x90, 0x10,
                0x7D, 0x74, 0xDA, 0xFC, 0x36, 0x09, 0xCC, 0xF7, 0x12, 0xB6, 0xF4, 0x94, 0xE9, 0x8B, 0x6A, 0x3B,
                0x5E, 0x71, 0x46, 0x3E, 0x0B, 0x78, 0xAD, 0x3B, 0x94, 0x5B, 0x89, 0x85, 0xA3, 0xE0, 0x01, 0xEB,
                0x84, 0x41, 0xAA, 0xD7, 0xB3, 0x17, 0x16, 0xC3, 0x6C, 0xB1, 0x81, 0x73, 0xEC, 0xE4, 0x6E, 0x09,
                0x56, 0xEE, 0x7A, 0xF6, 0x75, 0x6A, 0x73, 0x95, 0x8D, 0xDA, 0x51, 0x63, 0x8B, 0xBB, 0xE0, 0x4D,
                0xF8, 0xA0, 0x27, 0xF2, 0x9F, 0xC8, 0x15, 0x5A, 0x23, 0x85, 0x58, 0x04, 0x4A, 0x57, 0x28, 0x20,
                0x6D, 0x9D, 0x85, 0x83, 0x3C, 0xBF, 0x02, 0xB0, 0x96, 0xE8, 0x73, 0x6F, 0x20, 0x6E, 0xB0, 0xE4,
                0xC6, 0xFA, 0x71, 0xA6, 0x5D, 0xC5, 0xA0, 0xA3, 0xF8, 0x5C, 0x99, 0xCB, 0x9C, 0x04, 0x3A, 0xB2,
                0x04, 0x8D, 0xA2, 0x9D, 0x32, 0xF0, 0xBD, 0xAA, 0xEA, 0x81, 0x79, 0xE2, 0xA1, 0xBA, 0x89, 0x12,
                0xD5, 0x9F, 0x81, 0xEB, 0x63, 0xE7, 0xE5, 0xD4, 0xE9, 0x0E, 0x30, 0xBC, 0xCB, 0x70, 0xDD, 0x51,
                0x77, 0xC0, 0x80, 0xB3, 0x49, 0x03, 0x9A, 0xB8, 0x8C, 0xA7, 0x63, 0x62, 0x8F, 0x72, 0x5C, 0xA6,
                0xA0, 0xCF, 0x4F, 0xB4, 0x86, 0xFD, 0x49, 0xFA, 0x4A, 0x85, 0xDB, 0xFE, 0x61, 0xB7, 0x3A, 0xD7,
                0x83, 0x70, 0x57, 0x49, 0x83, 0xA7, 0x10, 0x73, 0x74, 0x37, 0x87, 0xFD, 0x6B, 0x28, 0xB7, 0x31,
                0x1E, 0x54, 0x1C, 0xE9, 0xD0, 0xB1, 0xCA, 0x76, 0x3B, 0x21, 0xF7, 0x67, 0xBB, 0x48, 0x69, 0x39 },
            new byte[] { 0x8D, 0xD1, 0x8C, 0x7B, 0x83, 0x8C, 0xA8, 0x18, 0xA7, 0x4A, 0x14, 0x03, 0x88, 0xB3, 0xCE, 0x74,
                0xBF, 0x5B, 0x87, 0x67, 0xA7, 0x85, 0x6B, 0x62, 0x96, 0x7C, 0xA9, 0xA6, 0xF6, 0x9E, 0xF4, 0x73,
                0xC5, 0xC4, 0xB0, 0x2B, 0x73, 0x2E, 0x36, 0x77, 0xDF, 0xBA, 0x57, 0xFF, 0x7F, 0xE9, 0x84, 0xE1,
                0x8D, 0x7B, 0xA2, 0xEF, 0x4F, 0x10, 0xF3, 0xD3, 0xE8, 0xB4, 0xBA, 0x20, 0x28, 0x79, 0x18, 0xD6,
                0x0F, 0x1C, 0xAA, 0xBD, 0x0E, 0x45, 0xF7, 0x6C, 0x68, 0xB9, 0x29, 0x40, 0x1A, 0xCF, 0xB6, 0x0A,
                0x13, 0xF8, 0xC0, 0x9C, 0x87, 0x10, 0x36, 0x14, 0x73, 0xA1, 0x75, 0x27, 0x14, 0x55, 0xAF, 0x78,
                0x9A, 0x08, 0xC9, 0x05, 0xF2, 0xEC, 0x24, 0x1B, 0x07, 0x4A, 0xDC, 0xF6, 0x48, 0xC6, 0x25, 0xCD,
                0x12, 0x1D, 0xAF, 0x51, 0x8F, 0xE9, 0xCA, 0x2C, 0x80, 0x57, 0x78, 0xB7, 0x96, 0x07, 0x19, 0x77,
                0x6E, 0x16, 0x45, 0x47, 0x8E, 0x9C, 0x18, 0x55, 0xF1, 0x72, 0xB3, 0x8A, 0xEA, 0x4E, 0x8D, 0x90,
                0x2E, 0xBC, 0x08, 0xAC, 0xF6, 0xA0, 0x5C, 0x16, 0xE3, 0x7A, 0xEE, 0x67, 0xB8, 0x58, 0xDC, 0x16,
                0x40, 0xED, 0xF9, 0x18, 0xB3, 0x0E, 0xD8, 0xEE, 0xE1, 0xFA, 0xC3, 0x9F, 0x82, 0x99, 0x32, 0x41,
                0x34, 0xBE, 0xC9, 0x50, 0x36, 0xE5, 0x66, 0xAA, 0x0D, 0x43, 0xF0, 0x3F, 0x26, 0x7C, 0xF3, 0x87,
                0x26, 0xA4, 0xF5, 0xF8, 0xA0, 0x32, 0x46, 0x74, 0x2E, 0x5A, 0xE2, 0xE7, 0x6B, 0x02, 0xA8, 0xD0,
                0xCF, 0xB8, 0x33, 0x15, 0x3B, 0x4F, 0xC7, 0x7A, 0xE8, 0x3D, 0x75, 0xD2, 0xFE, 0x42, 0x22, 0x22,
                0xA8, 0x21, 0x33, 0xFB, 0xB0, 0x87, 0x92, 0x99, 0xCA, 0xD7, 0xD7, 0x88, 0xAC, 0xE4, 0x75, 0x83,
                0x56, 0xBF, 0xCE, 0xED, 0x4F, 0xF6, 0x22, 0x07, 0xCA, 0xBC, 0xD2, 0xEF, 0x1B, 0x75, 0xD6, 0x2D },
            new byte[] { 0xD2, 0x4F, 0x76, 0x51, 0xEB, 0xA1, 0xAD, 0x84, 0xD6, 0x19, 0xE6, 0x97, 0xD9, 0xD3, 0x58, 0x6B,
                0xFB, 0xB8, 0x20, 0xFD, 0x49, 0x56, 0x1B, 0x50, 0x61, 0x10, 0x57, 0xB8, 0x78, 0x07, 0xC1, 0x4A,
                0xA2, 0xEA, 0x47, 0x80, 0x00, 0x4A, 0xB3, 0x4E, 0x6F, 0x1A, 0xC1, 0xD5, 0x22, 0xF8, 0x54, 0x2F,
                0x33, 0xE5, 0x7F, 0xB4, 0x13, 0x02, 0xA3, 0xA1, 0x8B, 0x1C, 0x6F, 0x19, 0xD6, 0x42, 0xB3, 0x24,
                0x4B, 0x04, 0x30, 0x10, 0x02, 0x23, 0x6F, 0x10, 0x03, 0x4B, 0x0E, 0x33, 0x55, 0x22, 0xA4, 0x78,
                0xEC, 0xD2, 0x4A, 0x11, 0x8B, 0xFC, 0xFF, 0x14, 0x7A, 0xED, 0x06, 0x47, 0x86, 0xFC, 0xF0, 0x03,
                0x0F, 0x75, 0x07, 0xE4, 0x9A, 0xD3, 0xBB, 0x0D, 0x97, 0x1F, 0x6F, 0x80, 0x62, 0xA6, 0x9E, 0xC6,
                0xB1, 0x10, 0x81, 0xA1, 0x6D, 0x55, 0x0F, 0x9E, 0x1B, 0xB7, 0xF5, 0xDC, 0x62, 0xA8, 0x63, 0x58,
                0xCF, 0x2F, 0x6A, 0xAD, 0x5E, 0xD3, 0x3F, 0xBD, 0x8D, 0x9B, 0x2A, 0x8B, 0xDF, 0x60, 0xB9, 0xAF,
                0xAA, 0x70, 0xB4, 0xA8, 0x17, 0x99, 0x72, 0xB9, 0x88, 0x9D, 0x3D, 0x2A, 0x11, 0x87, 0x1E, 0xF3,
                0x9D, 0x33, 0x8D, 0xED, 0x52, 0x60, 0x36, 0x71, 0xFF, 0x7B, 0x37, 0x84, 0x3D, 0x27, 0x9E, 0xD9,
                0xDF, 0x58, 0xF7, 0xC2, 0x58, 0x0C, 0x9D, 0x5E, 0xEE, 0x23, 0x83, 0x70, 0x3F, 0x95, 0xBC, 0xF5,
                0x42, 0x86, 0x91, 0x5B, 0x3F, 0x77, 0x31, 0xD2, 0xB7, 0x09, 0x59, 0x53, 0xF5, 0xF2, 0xE5, 0xF1,
                0xDC, 0x92, 0x83, 0x14, 0xC1, 0xA2, 0x25, 0x62, 0x13, 0xFD, 0xD4, 0xC5, 0x54, 0x9D, 0x9C, 0x27,
                0x6C, 0xC2, 0x75, 0x8B, 0xBC, 0xC7, 0x4E, 0x0A, 0xF6, 0x5C, 0x2F, 0x12, 0x8E, 0x25, 0xBB, 0xF2,
                0x5F, 0x89, 0xAA, 0xEA, 0xD9, 0xCD, 0x05, 0x74, 0x20, 0xD6, 0x17, 0xED, 0xF0, 0x66, 0x6C, 0x7B },
        };
        private static readonly uint[] DefKey = new uint[] { 0xD0DBA9D7u, 0x13A0A96Cu, 0x80410DF0u, 0x2CCDBE1Fu, 0xE570A86Bu };
        private static readonly byte[] FileKey = new byte[]
        { 0x2B, 0xF3, 0x2C, 0x6A, 0x73, 0x33, 0xCC, 0xD6, 0x01, 0x8F, 0x28, 0x26, 0xF0, 0xD6, 0xAF, 0xBF,
            0xEB, 0x7C, 0xCF, 0x96, 0xAD, 0x40, 0x35, 0x16, 0xB1, 0x84, 0x8D, 0x29, 0x08, 0x86, 0x78, 0xE5,
            0x06, 0x86, 0x7D, 0xCC, 0xA5, 0x45, 0x9D, 0x26, 0xB5, 0x0E, 0x97, 0x87, 0xCB, 0x45, 0xEA, 0x61,
            0xC0, 0xC2, 0x13, 0xEB, 0x44, 0x34, 0xB8, 0xB7, 0x17, 0xFB, 0x2A, 0x06, 0xB4, 0x19, 0xB3, 0xAD,
            0x3F, 0x98, 0xEB, 0xCC, 0xF1, 0x21, 0xB5, 0x89, 0x82, 0x37, 0x52, 0xAF, 0x19, 0xF6, 0xF9, 0x55,
            0x25, 0x2E, 0xF0, 0x6B, 0xB2, 0x7A, 0x37, 0x24, 0xDA, 0x0F, 0xA6, 0x50, 0x9E, 0xF0, 0x13, 0x66,
            0xB9, 0x60, 0xB7, 0x31, 0x3D, 0x9F, 0x89, 0xE3, 0x10, 0x40, 0x04, 0xEA, 0x73, 0x87, 0x33, 0x5D,
            0xFA, 0xA8, 0x47, 0x6B, 0x5B, 0xF2, 0x7D, 0x64, 0x04, 0x2E, 0x82, 0x4E, 0x1C, 0x19, 0x7E, 0x42,
            0xC6, 0xE0, 0x0D, 0x5E, 0x1D, 0x2C, 0xBD, 0x39, 0xD5, 0x13, 0x5D, 0x3F, 0x58, 0xF1, 0x7C, 0xA1,
            0x27, 0x44, 0xE6, 0xD6, 0x34, 0xF3, 0x9F, 0x8D, 0x61, 0x12, 0x78, 0xFA, 0xD8, 0x3C, 0x04, 0xA8,
            0x50, 0x09, 0xEE, 0x59, 0xEC, 0x5A, 0xD4, 0x4F, 0xFB, 0x2B, 0xB4, 0xD5, 0xBE, 0x4E, 0xD2, 0x8D,
            0xD6, 0x07, 0x26, 0xAC, 0x24, 0x11, 0x1D, 0x5B, 0x7C, 0xD4, 0xEC, 0xD4, 0x1D, 0xBE, 0xB1, 0x6E,
            0x72, 0x93, 0x0E, 0x37, 0xCE, 0x97, 0xCD, 0x8D, 0xAA, 0xB4, 0xAA, 0x48, 0x0D, 0xED, 0xB2, 0x94,
            0x25, 0xDF, 0x70, 0x1E, 0xB2, 0x34, 0xFE, 0xDF, 0x2E, 0xF7, 0x8D, 0x4C, 0x08, 0x6F, 0xE0, 0xE8,
            0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x20, 0xA9,
            0x20, 0x50, 0x65, 0x6C, 0x69, 0x63, 0x61, 0x6E, 0x20, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x6F,
            0x72, 0x69, 0x65, 0x73, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x2C, 0x20, 0x43, 0x4D, 0x47, 0x53,
            0x43, 0x43, 0x43, 0x2E, 0x63, 0x6F, 0x6D, 0x20, 0x26, 0x20, 0x53, 0x6D, 0x69, 0x6C, 0x65, 0x79,
            0x0D, 0x0A, 0x0D, 0x0A, 0x20, 0x20, 0x41, 0x20, 0x42, 0x49, 0x47, 0x20, 0x73, 0x68, 0x6F, 0x75,
            0x74, 0x6F, 0x75, 0x74, 0x20, 0x28, 0x2F, 0x73, 0x61, 0x72, 0x63, 0x61, 0x73, 0x6D, 0x29, 0x20,
            0x67, 0x6F, 0x65, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20,
            0x6C, 0x6F, 0x73, 0x65, 0x72, 0x73, 0x20, 0x77, 0x68, 0x6F, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75,
            0x73, 0x0D, 0x0A, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x39, 0x20, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x73,
            0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6B, 0x69, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73,
            0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x65, 0x61, 0x74, 0x20, 0x6D,
            0x61, 0x72, 0x6B, 0x65, 0x74, 0x20, 0x28, 0x79, 0x6F, 0x75, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 0x20,
            0x77, 0x68, 0x6F, 0x0D, 0x0A, 0x79, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x29, 0x2E, 0x20, 0x54,
            0x68, 0x65, 0x20, 0x73, 0x61, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20,
            0x79, 0x6F, 0x75, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x65, 0x20, 0x61,
            0x72, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x66, 0x75, 0x6C, 0x6C,
            0x20, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x0D, 0x0A, 0x61, 0x68, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x72,
            0x65, 0x61, 0x64, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x6B, 0x69, 0x63, 0x6B, 0x20, 0x61, 0x73, 0x73,
            0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x73, 0x20,
            0x6C, 0x61, 0x74, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x61,
            0x6B, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x0D, 0x0A, 0x70, 0x72, 0x69, 0x73, 0x6F, 0x6E, 0x65,
            0x72, 0x73, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x20, 0x74,
            0x6F, 0x20, 0x64, 0x69, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x2E, 0x20, 0x57, 0x65, 0x20, 0x61,
            0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x70, 0x75, 0x74, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x66,
            0x69, 0x73, 0x68, 0x20, 0x64, 0x65, 0x61, 0x64, 0x0D, 0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65,
            0x20, 0x77, 0x61, 0x74, 0x65, 0x72, 0x2C, 0x20, 0x77, 0x68, 0x6F, 0x73, 0x20, 0x6E, 0x65, 0x78,
            0x74, 0x3F, 0x0D, 0x0A, 0x20, 0x2D, 0x43, 0x4D, 0x58, 0x0D, 0x0A, 0x0D, 0x0A, 0x20, 0x20, 0x20,
            0x20, 0x41, 0x20, 0x77, 0x69, 0x73, 0x65, 0x6D, 0x61, 0x6E, 0x20, 0x6F, 0x6E, 0x63, 0x65, 0x20,
            0x73, 0x61, 0x69, 0x64, 0x3A, 0x0D, 0x0A, 0x0D, 0x0A, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68,
            0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63,
            0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x65, 0x20, 0x61, 0x6C, 0x6C,
            0x20, 0x6A, 0x75, 0x73, 0x74, 0x0D, 0x0A, 0x68, 0x65, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6F,
            0x72, 0x20, 0x0D, 0x64, 0x6F, 0x6F, 0x6D, 0x2C, 0x20, 0x73, 0x74, 0x69, 0x6C, 0x6C, 0x20, 0x63,
            0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62,
            0x65, 0x61, 0x73, 0x74, 0x0D, 0x0A, 0x41, 0x6E, 0x64, 0x20, 0x49, 0x20, 0x6B, 0x6E, 0x6F, 0x77,
            0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x6E, 0x65, 0x76, 0x65,
            0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63, 0x65, 0x0D, 0x0A, 0x54, 0x68, 0x61, 0x74,
            0x27, 0x73, 0x20, 0x77, 0x68, 0x79, 0x20, 0x49, 0x20, 0x6B, 0x65, 0x65, 0x70, 0x20, 0x6D, 0x79,
            0x20, 0x70, 0x69, 0x73, 0x74, 0x6F, 0x6C, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x49, 0x20, 0x77,
            0x61, 0x6C, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74, 0x73, 0x0D,
            0x0A, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x75,
            0x6C, 0x64, 0x20, 0x6E, 0x65, 0x76, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63,
            0x65, 0x0D, 0x0A, 0x0D, 0x0A, 0x28, 0x54, 0x68, 0x65, 0x20, 0x76, 0x69, 0x65, 0x77, 0x73, 0x20,
            0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x62, 0x6F, 0x76, 0x65, 0x20,
            0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x6F, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x43, 0x4D, 0x58,
            0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x69, 0x65,
            0x77, 0x73, 0x20, 0x6F, 0x66, 0x0D, 0x0A, 0x50, 0x65, 0x6C, 0x69, 0x63, 0x61, 0x6E, 0x20, 0x41,
            0x63, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x69, 0x65, 0x73, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E,
            0x20, 0x6F, 0x72, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x63, 0x6F, 0x64, 0x65, 0x62, 0x72, 0x65, 0x61,
            0x6B, 0x65, 0x72, 0x2E, 0x63, 0x6F, 0x6D, 0x29, 0x0A, 0x00, 0x00, 0x00, 0xBE, 0xEF, 0xBE, 0xEF };

        // Runtime mutable V7 state
        private static readonly byte[][] Seeds = new byte[][]
        {
            new byte[256],
            new byte[256],
            new byte[256],
            new byte[256],
            new byte[256]
        };

        private static readonly uint[] Key    = new uint[5];
        private static readonly uint[] OldKey = new uint[5];

        // ARCFOUR (RC4) context and helpers – direct port of arc4_ctx_t / arc4_init / arc4_crypt.
        private sealed class Arc4Context
        {
            public byte[] Perm = new byte[256];
            public byte Index1;
            public byte Index2;
        }

        private static void Arc4Init(Arc4Context ctx, byte[] keyBytes, int keyLength)
        {
            if (ctx == null) throw new ArgumentNullException(nameof(ctx));
            if (keyBytes == null) throw new ArgumentNullException(nameof(keyBytes));
            if (keyLength <= 0 || keyLength > keyBytes.Length)
                throw new ArgumentOutOfRangeException(nameof(keyLength));

            unchecked
            {
                // Initialize context with identity permutation
                for (int i = 0; i < 256; i++)
                    ctx.Perm[i] = (byte)i;
                ctx.Index1 = 0;
                ctx.Index2 = 0;

                // Randomize the permutation using key data
                byte j = 0;
                for (int i = 0; i < 256; i++)
                {
                    j = (byte)(j + ctx.Perm[i] + keyBytes[i % keyLength]);
                    byte tmp = ctx.Perm[i];
                    ctx.Perm[i] = ctx.Perm[j];
                    ctx.Perm[j] = tmp;
                }
            }
        }

        private static void Arc4Crypt(Arc4Context ctx, byte[] buffer, int offset, int count)
        {
            if (ctx == null) throw new ArgumentNullException(nameof(ctx));
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));
            if (offset < 0 || count < 0 || offset + count > buffer.Length)
                throw new ArgumentOutOfRangeException();

            unchecked
            {
                byte i1 = ctx.Index1;
                byte i2 = ctx.Index2;

                for (int n = 0; n < count; n++)
                {
                    // Update modification indices
                    i1++;
                    i2 = (byte)(i2 + ctx.Perm[i1]);

                    // Modify permutation
                    byte tmp = ctx.Perm[i1];
                    ctx.Perm[i1] = ctx.Perm[i2];
                    ctx.Perm[i2] = tmp;

                    // Encrypt/decrypt next byte
                    byte j = (byte)(ctx.Perm[i1] + ctx.Perm[i2]);
                    buffer[offset + n] ^= ctx.Perm[j];
                }

                ctx.Index1 = i1;
                ctx.Index2 = i2;
            }
        }

        /// <summary>
        /// Get the current V7 key as a 20‑byte little‑endian buffer (5 x 32‑bit words).
        /// This mirrors the original C layout where key was a u32[5] cast to u8*.
        /// </summary>
        private static byte[] GetKeyBytes()
        {
            var bytes = new byte[20];
            for (int i = 0; i < 5; i++)
            {
                uint v = Key[i];
                int o = i * 4;
                bytes[o + 0] = (byte)(v & 0xFF);
                bytes[o + 1] = (byte)((v >> 8) & 0xFF);
                bytes[o + 2] = (byte)((v >> 16) & 0xFF);
                bytes[o + 3] = (byte)((v >> 24) & 0xFF);
            }
            return bytes;
        }

        /// <summary>
        /// Get a 32‑bit little‑endian word from the Seeds buffer.
        /// Equivalent to ((u32*)seeds[row])[index] in the original C code.
        /// </summary>
        private static uint GetSeedWord(int row, int index)
        {
            var rowBytes = Seeds[row];
            int offset = index * 4;
            return (uint)(rowBytes[offset + 0]
                          | (rowBytes[offset + 1] << 8)
                          | (rowBytes[offset + 2] << 16)
                          | (rowBytes[offset + 3] << 24));
        }

        /// <summary>
        /// Set up V7 in the same way as CBSetCommonV7() in the C code.
        /// </summary>
        public static void CBSetCommonV7()
        {
            v7enc = true;
            CB7Beefcode(true, 0);
            v7init = true;
            beefcodf = 0;
        }

        /// <summary>
        /// Seed/key update routine used by BEEFC0DE/BEEFC0DF handling.
        /// Direct port of CB7Beefcode(int init, u32 val).
        /// </summary>
        private static void CB7Beefcode(bool init, uint val)
        {
            // Easy access to all bytes of val (little‑endian).
            byte[] p = BitConverter.GetBytes(val);

            if (init)
            {
                beefcodf = 0;
                //unkwn = 0; // unused in this port

                // Copy default key
                for (int i = 0; i < 5; i++)
                    Key[i] = DefKey[i];

                if (val != 0)
                {
                    // Copy default seeds
                    for (int r = 0; r < 5; r++)
                        Array.Copy(DefSeeds[r], Seeds[r], 256);

                    Key[0] = (uint)((Seeds[3][p[3]] << 24) | (Seeds[2][p[2]] << 16) | (Seeds[1][p[1]] << 8) | Seeds[0][p[0]]);
                    Key[1] = (uint)((Seeds[0][p[3]] << 24) | (Seeds[3][p[2]] << 16) | (Seeds[2][p[1]] << 8) | Seeds[1][p[0]]);
                    Key[2] = (uint)((Seeds[1][p[3]] << 24) | (Seeds[0][p[2]] << 16) | (Seeds[3][p[1]] << 8) | Seeds[2][p[0]]);
                    Key[3] = (uint)((Seeds[2][p[3]] << 24) | (Seeds[1][p[2]] << 16) | (Seeds[0][p[1]] << 8) | Seeds[3][p[0]]);
                }
                else
                {
                    // Clear seeds entirely
                    for (int r = 0; r < 5; r++)
                        Array.Clear(Seeds[r], 0, Seeds[r].Length);
                }
            }
            else
            {
                if (val != 0)
                {
                    Key[0] = (uint)((Seeds[3][p[3]] << 24) | (Seeds[2][p[2]] << 16) | (Seeds[1][p[1]] << 8) | Seeds[0][p[0]]);
                    Key[1] = (uint)((Seeds[0][p[3]] << 24) | (Seeds[3][p[2]] << 16) | (Seeds[2][p[1]] << 8) | Seeds[1][p[0]]);
                    Key[2] = (uint)((Seeds[1][p[3]] << 24) | (Seeds[0][p[2]] << 16) | (Seeds[3][p[1]] << 8) | Seeds[2][p[0]]);
                    Key[3] = (uint)((Seeds[2][p[3]] << 24) | (Seeds[1][p[2]] << 16) | (Seeds[0][p[1]] << 8) | Seeds[3][p[0]]);
                }
                else
                {
                    for (int r = 0; r < 5; r++)
                        Array.Clear(Seeds[r], 0, Seeds[r].Length);
                    Key[0] = 0;
                    Key[1] = 0;
                    Key[2] = 0;
                    Key[3] = 0;
                }
            }

            // Use key to encrypt seeds with ARCFOUR algorithm
            var ctx = new Arc4Context();
            for (int i = 0; i < 5; i++)
            {
                // Setup ARCFOUR context with key
                byte[] keyBytes = GetKeyBytes();
                Arc4Init(ctx, keyBytes, 20);

                // Encrypt seeds row
                Arc4Crypt(ctx, Seeds[i], 0, 256);

                // Encrypt original key for next round
                Arc4Crypt(ctx, keyBytes, 0, 20);
                // Copy back into Key[] as little‑endian u32 words
                for (int k = 0; k < 5; k++)
                {
                    int o = k * 4;
                    Key[k] = (uint)(keyBytes[o + 0]
                                   | (keyBytes[o + 1] << 8)
                                   | (keyBytes[o + 2] << 16)
                                   | (keyBytes[o + 3] << 24));
                }
            }

            // Backup key
            for (int i = 0; i < 5; i++)
                OldKey[i] = Key[i];
        }

        /// <summary>
        /// V7 encrypt – direct port of CB7EncryptCode().
        /// </summary>
        private static void CB7EncryptCode(ref uint addr, ref uint val)
        {
            unchecked
            {
                uint oldaddr = addr;
                uint oldval  = val;

                // Step 1: Multiplication, modulo 2^32
                addr = MulEncrypt(addr, OldKey[0] - OldKey[1]);
                val  = MulEncrypt(val,  OldKey[2] + OldKey[3]);

                // Step 2: ARCFOUR on the two words using current Key
                uint[] code = { addr, val };
                byte[] keyBytes = GetKeyBytes();
                var ctx = new Arc4Context();
                Arc4Init(ctx, keyBytes, 20);

                // Serialize code as little‑endian bytes
                byte[] codeBytes = new byte[8];
                for (int i = 0; i < 2; i++)
                {
                    uint v = code[i];
                    int o = i * 4;
                    codeBytes[o + 0] = (byte)(v & 0xFF);
                    codeBytes[o + 1] = (byte)((v >> 8) & 0xFF);
                    codeBytes[o + 2] = (byte)((v >> 16) & 0xFF);
                    codeBytes[o + 3] = (byte)((v >> 24) & 0xFF);
                }
                Arc4Crypt(ctx, codeBytes, 0, 8);
                // Convert back to u32
                addr = (uint)(codeBytes[0] | (codeBytes[1] << 8) | (codeBytes[2] << 16) | (codeBytes[3] << 24));
                val  = (uint)(codeBytes[4] | (codeBytes[5] << 8) | (codeBytes[6] << 16) | (codeBytes[7] << 24));

                // Step 3: RSA (encode)
                RSAEncode(ref addr, ref val);

                // Step 4: Encryption loop of 64 cycles, using the generated seeds
                for (int i = 0; i <= 63; i++)
                {
                    uint s0 = GetSeedWord(0, i);
                    uint s1 = GetSeedWord(1, i);
                    uint s2 = GetSeedWord(2, i);
                    uint s3 = GetSeedWord(3, i);
                    uint s4 = GetSeedWord(4, i);

                    addr = ((addr + s2) ^ s0) - (val ^ s4);
                    val  = ((val  - s3) ^ s1) + (addr ^ s4);
                }

                // BEEFC0DE
                if ((oldaddr & 0xFFFFFFFEu) == 0xBEEFC0DEu)
                {
                    CB7Beefcode(false, oldval);
                    //beefcodf = 1;
                    return;
                }

                // BEEFC0DF
                if (beefcodf != 0)
                {
                    uint[] beefCode = { oldaddr, oldval };
                    byte[] beefBytes = new byte[8];
                    for (int i = 0; i < 2; i++)
                    {
                        uint v = beefCode[i];
                        int o = i * 4;
                        beefBytes[o + 0] = (byte)(v & 0xFF);
                        beefBytes[o + 1] = (byte)((v >> 8) & 0xFF);
                        beefBytes[o + 2] = (byte)((v >> 16) & 0xFF);
                        beefBytes[o + 3] = (byte)((v >> 24) & 0xFF);
                    }

                    var beefCtx = new Arc4Context();
                    Arc4Init(beefCtx, beefBytes, 8);

                    // Flatten Seeds into a single 5*256 buffer for RC4 and back
                    byte[] seedsFlat = new byte[5 * 256];
                    for (int r = 0; r < 5; r++)
                        Buffer.BlockCopy(Seeds[r], 0, seedsFlat, r * 256, 256);
                    Arc4Crypt(beefCtx, seedsFlat, 0, seedsFlat.Length);
                    for (int r = 0; r < 5; r++)
                        Buffer.BlockCopy(seedsFlat, r * 256, Seeds[r], 0, 256);

                    beefcodf = 0;
                    //unkwn = 0;
                    return;
                }
            }
        }

        /// <summary>
        /// V7 decrypt – direct port of CB7DecryptCode().
        /// </summary>
        private static void CB7DecryptCode(ref uint addr, ref uint val)
        {
            unchecked
            {
                // Step 1: Decryption loop of 64 cycles, using the generated seeds
                for (int i = 63; i >= 0; i--)
                {
                    uint s0 = GetSeedWord(0, i);
                    uint s1 = GetSeedWord(1, i);
                    uint s2 = GetSeedWord(2, i);
                    uint s3 = GetSeedWord(3, i);
                    uint s4 = GetSeedWord(4, i);

                    val  = ((val  - (addr ^ s4)) ^ s1) + s3;
                    addr = ((addr + (val  ^ s4)) ^ s0) - s2;
                }

                // Step 2: RSA (decode)
                RSADecode(ref addr, ref val);

                // Step 3: ARCFOUR on the two words using current Key
                uint[] code = { addr, val };
                byte[] keyBytes = GetKeyBytes();
                var ctx = new Arc4Context();
                Arc4Init(ctx, keyBytes, 20);

                byte[] codeBytes = new byte[8];
                for (int i = 0; i < 2; i++)
                {
                    uint v = code[i];
                    int o = i * 4;
                    codeBytes[o + 0] = (byte)(v & 0xFF);
                    codeBytes[o + 1] = (byte)((v >> 8) & 0xFF);
                    codeBytes[o + 2] = (byte)((v >> 16) & 0xFF);
                    codeBytes[o + 3] = (byte)((v >> 24) & 0xFF);
                }
                Arc4Crypt(ctx, codeBytes, 0, 8);
                addr = (uint)(codeBytes[0] | (codeBytes[1] << 8) | (codeBytes[2] << 16) | (codeBytes[3] << 24));
                val  = (uint)(codeBytes[4] | (codeBytes[5] << 8) | (codeBytes[6] << 16) | (codeBytes[7] << 24));

                // Step 4: Multiplication with multiplicative inverse, modulo 2^32
                addr = MulDecrypt(addr, OldKey[0] - OldKey[1]);
                val  = MulDecrypt(val,  OldKey[2] + OldKey[3]);

                // BEEFC0DF
                if (beefcodf != 0)
                {
                    uint[] code2 = { addr, val };
                    byte[] codeBytes2 = new byte[8];
                    for (int i = 0; i < 2; i++)
                    {
                        uint v = code2[i];
                        int o = i * 4;
                        codeBytes2[o + 0] = (byte)(v & 0xFF);
                        codeBytes2[o + 1] = (byte)((v >> 8) & 0xFF);
                        codeBytes2[o + 2] = (byte)((v >> 16) & 0xFF);
                        codeBytes2[o + 3] = (byte)((v >> 24) & 0xFF);
                    }

                    var ctx2 = new Arc4Context();
                    Arc4Init(ctx2, codeBytes2, 8);
                    byte[] seedsFlat = new byte[5 * 256];
                    for (int r = 0; r < 5; r++)
                        Buffer.BlockCopy(Seeds[r], 0, seedsFlat, r * 256, 256);
                    Arc4Crypt(ctx2, seedsFlat, 0, seedsFlat.Length);
                    for (int r = 0; r < 5; r++)
                        Buffer.BlockCopy(seedsFlat, r * 256, Seeds[r], 0, 256);

                    beefcodf = 0;
                    //unkwn = 0;
                    return;
                }

                // BEEFC0DE
                if ((addr & 0xFFFFFFFEu) == 0xBEEFC0DEu)
                {
                    CB7Beefcode(false, val);
                    //beefcodf = 1;
                    return;
                }
                /*
                if (unkwn)
                {
                    Key[0] = addr ^ OldKey[0];
                    Key[1] = val  ^ OldKey[1];
                    Key[2] = addr - OldKey[2];
                    Key[3] = val  + OldKey[3];
                    Key[4] = (addr - val) ^ OldKey[4];
                }
                */
            }
        }

        /// <summary>
        /// Encrypt/decrypt arbitrary CB2 file data using the fixed file key.
        /// Direct port of CBCryptFileData().
        /// </summary>
        public static void CBCryptFileData(byte[] data, int dataSize)
        {
            if (data == null) throw new ArgumentNullException(nameof(data));
            if (dataSize < 0 || dataSize > data.Length)
                throw new ArgumentOutOfRangeException(nameof(dataSize));

            var ctx = new Arc4Context();
            Arc4Init(ctx, FileKey, FileKey.Length);
            Arc4Crypt(ctx, data, 0, dataSize);
        }


/// <summary>
/// Encrypt a V1 CodeBreaker code in-place (addr/val). Direct port of CB1EncryptCode().
/// </summary>
public static void CB1EncryptCode(ref uint addr, ref uint val)
{
    unchecked
    {
        uint tmp;
        byte cmd = (byte)(addr >> 28);

        tmp = addr & 0xFF000000U;
        addr = ((addr & 0xFFU) << 16) | ((addr >> 8) & 0xFFFFU);
        addr = (tmp | ((addr + SeedTable[1, cmd]) & 0x00FFFFFFU)) ^ SeedTable[0, cmd];

        if (cmd > 2)
        {
            val = addr ^ (val + SeedTable[2, cmd]);
        }
    }
}

/// <summary>
/// Decrypt a V1 CodeBreaker code in-place (addr/val). Direct port of CB1DecryptCode().
/// </summary>
public static void CB1DecryptCode(ref uint addr, ref uint val)
{
    unchecked
    {
        uint tmp;
        byte cmd = (byte)(addr >> 28);

        if (cmd > 2)
        {
            val = (addr ^ val) - SeedTable[2, cmd];
        }

        tmp = addr ^ SeedTable[0, cmd];
        addr = tmp - SeedTable[1, cmd];
        addr = (tmp & 0xFF000000U) | ((addr & 0xFFFFU) << 8) | ((addr >> 16) & 0xFFU);
    }
}

/// <summary>
/// Public CB2 encrypt wrapper. Currently implements V1 (CB1EncryptCode) only.
/// V7 (CB7EncryptCode) and BEEFC0DE handling will be added in a later step.
/// </summary>

        /// <summary>
        /// Encrypt a CodeBreaker code in-place (addr/val).
        /// Dispatches to V1 or V7 path depending on v7enc flag,
        /// matching the original CBEncryptCode() behavior.
        /// </summary>
        public static void CBEncryptCode(ref uint addr, ref uint val)
        {
            uint oldaddr = addr;
            uint oldval  = val;

            if (v7enc)
                CB7EncryptCode(ref addr, ref val);
            else
                CB1EncryptCode(ref addr, ref val);

            // BEEFC0DE detection on the *original* address word
            if ((oldaddr & 0xFFFFFFFEu) == 0xBEEFC0DEu)
            {
                if (!v7init)
                {
                    // Init seeds
                    CB7Beefcode(true, oldval);
                    v7init = true;
                }
                else
                {
                    // Change original seeds
                    CB7Beefcode(false, oldval);
                }
                v7enc = true;
                beefcodf = (int)(oldaddr & 1u);
            }
        }


/// <summary>
/// Public CB2 decrypt wrapper. Currently implements V1 (CB1DecryptCode) only.
/// V7 (CB7DecryptCode) and BEEFC0DE handling will be added in a later step.
/// </summary>

        /// <summary>
        /// Decrypt a CodeBreaker code in-place (addr/val).
        /// Dispatches to V1 or V7 path depending on v7enc flag,
        /// matching the original CBDecryptCode() behavior.
        /// </summary>
        public static void CBDecryptCode(ref uint addr, ref uint val)
        {
            if (v7enc)
                CB7DecryptCode(ref addr, ref val);
            else
                CB1DecryptCode(ref addr, ref val);

            // BEEFC0DE detection on the *current* address word
            if ((addr & 0xFFFFFFFEu) == 0xBEEFC0DEu)
            {
                if (!v7init)
                {
                    // Init seeds
                    CB7Beefcode(true, val);
                    v7init = true;
                }
                else
                {
                    // Change original seeds
                    CB7Beefcode(false, val);
                }
                v7enc = true;
                beefcodf = (int)(addr & 1u);
            }
        }


/// <summary>
/// Batch decrypt a cheat_t code list using CBDecryptCode().
/// Direct port of CBBatchDecrypt(), minus the BEEFC0DE clean-up which will
/// depend on the full V7 port. This safely processes all pairs as-is.
/// </summary>

        /// <summary>
        /// Batch decrypt a cheat_t code list using CBDecryptCode().
        /// Direct 1:1 port of CBBatchDecrypt(), including BEEFC0DE clean-up.
        /// </summary>
                public static void CBBatchDecrypt(cheat_t cheat)
        {
            if (cheat == null || cheat.codecnt <= 0 || cheat.code == null)
                return;

            int i = 0;
            bool wasBeefcode = false;
            int num = 0;

            while (i < cheat.codecnt)
            {
                if (i + 1 >= cheat.codecnt)
                    break;

                uint addr = cheat.code[i];
                uint val = cheat.code[i + 1];

                // Decrypt this pair (V1 or V7, depending on v7enc / BEEFC0DE state)
                CBDecryptCode(ref addr, ref val);

                cheat.code[i] = addr;
                cheat.code[i + 1] = val;

                // BEEFC0DE detection on the *current* address word, matching CBBatchDecrypt()
                if ((addr & 0xFFFFFFFEu) == 0xBEEFC0DEu)
                {
                    wasBeefcode = true;

                    // Remove the two octets following the BEEFC0DE marker
                    Cheat.cheatRemoveOctets(cheat, i + 1, 2);

                    num = 0;
                    i -= 2;
                    if (i < 0)
                        i = 0;
                }
                else if (wasBeefcode)
                {
                    // Following the C logic: treat 000FFFFE / 000FFFFF as "beef-related"
                    if (addr == 0x000FFFFEu || addr == 0x000FFFFFu)
                    {
                        num++;

                        // Remove the two octets following this 0x000FFFFE/F marker
                        Cheat.cheatRemoveOctets(cheat, i + 1, 2);

                        i -= 2;
                        if (i < 0)
                            i = 0;
                    }
                    else
                    {
                        wasBeefcode = false;
                    }

                    if (num >= 2)
                        wasBeefcode = false;
                }

                i += 2;
            }
        }



/// <summary>
/// Batch encrypt a cheat_t code list using CBEncryptCode().
/// Direct port of CBBatchEncrypt() for the V1 path.
/// </summary>
public static void CBBatchEncrypt(cheat_t cheat)
{
    if (cheat == null || cheat.codecnt <= 0 || cheat.code == null)
        return;

    var code = cheat.code;
    int num = cheat.codecnt;

    for (int i = 0; i < num; i += 2)
    {
        uint addr = code[i];
        uint val = (i + 1 < num) ? code[i + 1] : 0U;
        CBEncryptCode(ref addr, ref val);
        code[i] = addr;
        if (i + 1 < num)
            code[i + 1] = val;
    }
}

    }
}
